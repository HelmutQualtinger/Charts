<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index-Performance-Vergleich (Basis 100 in CHF)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css">
    <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wnumb@1.2.0/wNumb.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #2a2a2a;
        }
        .controls label, .controls input { margin-right: 15px; }
        .controls input[type="date"] {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 5px;
        }
        .controls button {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background-color: #0052a3;
        }
        #loading { color: #4da6ff; font-weight: bold; margin-top: 10px; }
        #error { color: #ff6b6b; font-weight: bold; margin-top: 10px; }
        #chartContainer { width: 100%; height: 400px; position: relative; }
        canvas { max-width: 100%; height: auto; }
        #statistics {
            margin-top: 20px;
            padding: 15px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
        }
        #statistics h2 {
            margin-top: 0;
            color: #4da6ff;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            font-weight: bold;
        }
        #dateSlider {
            margin: 20px 0;
        }
        .noUi-connect {
            background: #0066cc;
        }
        .noUi-tooltip {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
        }
        .date-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            color: #e0e0e0;
        }
    </style>
</head>
<body>

    <h1>ðŸš€ Index-Performance-Vergleich (CHF, Basis 100)</h1>

    <div class="controls">
        <label>Datumsbereich:</label>
        <div id="dateSlider"></div>
        <div class="date-labels">
            <span id="startDateLabel">2000-01-01</span>
            <span id="endDateLabel">Heute</span>
        </div>
        <button onclick="loadAndRenderChart()" style="margin-top: 15px;">Chart aktualisieren</button>
    </div>

    <div id="loading" style="display:none;">Lade Daten... Dies kann einige Sekunden dauern.</div>
    <div id="error" style="display:none;">Fehler beim Laden oder Verarbeiten der Daten.</div>

    <div id="chartContainer">
        <canvas id="performanceChart"></canvas>
    </div>

    <div id="statistics">
        <h2>Performance Statistiken</h2>
        <div id="statsContent"></div>
    </div>

    <script>
        // --- KONFIGURATION ---
        const INDEXES = [
            { name: 'DAX (TR)', ticker: 'dax', currency: 'EUR', color: 'rgba(0, 104, 182, 1)' },
            { name: 'S&P 500 (TR)', ticker: 'sp500', currency: 'USD', color: 'rgba(75, 192, 192, 1)' },
            { name: 'SMI (TR)', ticker: 'smi', currency: 'CHF', color: 'rgba(255, 99, 132, 1)' },
            { name: 'Gold', ticker: 'gold', currency: 'USD', color: 'rgba(255, 215, 0, 1)' }
        ];
        const CURRENCY_TICKERS = {
            'EUR': 'eurChf',
            'USD': 'usdChf'
        };
        const TARGET_CURRENCY = 'CHF';

        let performanceChart; // Variable fÃ¼r das Chart-Objekt
        let dateSlider;
        let selectedStartDate = '2000-01-01';
        let selectedEndDate = new Date().toISOString().split('T')[0];
        let lastLoadDate = new Date().toDateString();

        /**
         * Ruft alle historischen Daten vom server.py ab.
         * @returns {Promise<Object>} - Objekt mit allen Ticker-Daten.
         */
        async function fetchAllData() {
            const apiUrl = 'http://127.0.0.1:5000/api/data/all';

            try {
                const response = await fetch(apiUrl);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server-Fehler: Status ${response.status}. Antwort: ${errorText.substring(0, 100)}...`);
                }

                const data = await response.json();
                return data;

            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                throw new Error(`Laden der Daten fehlgeschlagen. Originalfehler: ${error.message}`);
            }
        }
        /**
         * Hauptfunktion zum Laden und Rendern des Charts.
         */
        async function loadAndRenderChart() {
            const startDate = selectedStartDate;
            const endDate = selectedEndDate;
            lastLoadDate = new Date().toDateString();
            const loadingDiv = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';

            try {
                // 1. Alle Daten auf einmal laden
                const allData = await fetchAllData();

                // 2. Daten in das richtige Format konvertieren
                const exchangeRates = {};
                Object.entries(CURRENCY_TICKERS).forEach(([currency, ticker]) => {
                    exchangeRates[currency] = allData[ticker] || {};
                });

                const indexResults = INDEXES.map(index => ({
                    ...index,
                    data: Object.entries(allData[index.ticker] || {}).map(([date, close]) => ({
                        date,
                        close
                    }))
                }));

                // 3. Daten filtern nach Datum
                const startTime = new Date(startDate).getTime();
                const endTime = new Date(endDate).getTime();

                indexResults.forEach(index => {
                    index.data = index.data.filter(item => {
                        const itemTime = new Date(item.date).getTime();
                        return itemTime >= startTime && itemTime <= endTime;
                    });
                });

                // 4. Daten umrechnen, zusammenfÃ¼hren und skalieren
                const processedData = processAndScaleData(indexResults, exchangeRates);

                // 5. Chart rendern
                renderChart(processedData, startDate, endDate);

                // 6. Statistiken berechnen und anzeigen
                calculateAndDisplayStatistics(processedData, startDate, endDate);

            } catch (error) {
                console.error("Gesamtfehler:", error);
                errorDiv.textContent = `Fehler: ${error.message}`;
                errorDiv.style.display = 'block';
                errorDiv.style.color = 'red';
            } finally {
                loadingDiv.style.display = 'none';
            }
        }

        /**
         * Verarbeitet die Indexdaten, rechnet sie in CHF um und skaliert sie auf Basis 100.
         * @param {Array<Object>} indexResults - Geladene Indexdaten.
         * @param {Object} exchangeRates - Geladene Wechselkurse.
         * @returns {Object} - Objekt mit Labels und skalierten DatensÃ¤tzen.
         */
        function processAndScaleData(indexResults, exchangeRates) {
            const allDates = new Set();
            const rawDataMap = {}; // Speichert die Indexdaten nach Datum und Indexname

            // 1. Rohdaten zusammenfÃ¼hren und alle vorhandenen Daten finden
            indexResults.forEach(index => {
                const indexName = index.name;
                rawDataMap[indexName] = {};
                index.data.forEach(item => {
                    // WÃ¤hrungsumrechnung anwenden
                    let chfValue = item.close;
                    if (index.currency === 'EUR') {
                        const rate = exchangeRates['EUR'][item.date];
                        if (rate) chfValue *= rate;
                    } else if (index.currency === 'USD') {
                        const rate = exchangeRates['USD'][item.date];
                        if (rate) chfValue *= rate;
                    }

                    if (chfValue) {
                        rawDataMap[indexName][item.date] = chfValue;
                        allDates.add(item.date);
                    }
                });
            });

            const sortedDates = Array.from(allDates).sort();

            // Filtere nur Monatsenddaten (letzter Tag jedes Monats)
            const monthEndDates = [];
            let currentMonth = null;
            let lastDateInMonth = null;

            sortedDates.forEach(date => {
                const d = new Date(date);
                const monthKey = `${d.getFullYear()}-${d.getMonth()}`;

                if (currentMonth !== monthKey) {
                    if (lastDateInMonth) {
                        monthEndDates.push(lastDateInMonth);
                    }
                    currentMonth = monthKey;
                }
                lastDateInMonth = date;
            });

            // Letzten Monat hinzufÃ¼gen
            if (lastDateInMonth) {
                monthEndDates.push(lastDateInMonth);
            }

            const finalLabels = [];
            const datasets = INDEXES.map(index => ({
                label: index.name,
                data: [],
                borderColor: index.color,
                backgroundColor: 'transparent',
                borderWidth: 2,
                tension: 0.1,
                hidden: false
            }));

            // 2. Skalierungsfaktor bestimmen und endgÃ¼ltige Daten erstellen
            const initialValues = {}; // Speichert den ersten verfÃ¼gbaren Wert fÃ¼r jeden Index
            const lastKnownValues = {}; // FÃ¼r Forward-Fill

            for (const date of monthEndDates) {
                const dailyValues = {};
                let hasAnyData = false;

                // Sammle Werte fÃ¼r alle Indizes (mit Forward-Fill fÃ¼r fehlende Daten)
                for (const index of INDEXES) {
                    let value = rawDataMap[index.name][date];

                    // Forward-Fill: Verwende letzten bekannten Wert, wenn aktueller fehlt
                    if (!value && lastKnownValues[index.name]) {
                        value = lastKnownValues[index.name];
                    }

                    if (value) {
                        dailyValues[index.name] = value;
                        lastKnownValues[index.name] = value;
                        hasAnyData = true;

                        // Setze Basis-Wert fÃ¼r jeden Index beim ersten Auftreten
                        if (!initialValues[index.name]) {
                            initialValues[index.name] = value;
                        }
                    }
                }

                // Nur Datenpunkte hinzufÃ¼gen, wenn mindestens ein Index Daten hat
                if (hasAnyData) {
                    // Datenpunkt auf Basis 100 skalieren und hinzufÃ¼gen
                    finalLabels.push(date);
                    INDEXES.forEach((index, i) => {
                        if (dailyValues[index.name] && initialValues[index.name]) {
                            const scaledValue = (dailyValues[index.name] / initialValues[index.name]) * 100;
                            datasets[i].data.push({ x: date, y: scaledValue });
                        } else if (datasets[i].data.length > 0) {
                            // Wenn kein Wert vorhanden, verwende letzten Wert
                            const lastValue = datasets[i].data[datasets[i].data.length - 1].y;
                            datasets[i].data.push({ x: date, y: lastValue });
                        } else {
                            // Noch keine Daten fÃ¼r diesen Index, fÃ¼ge null hinzu
                            datasets[i].data.push({ x: date, y: null });
                        }
                    });
                }
            }
            
            return { labels: finalLabels, datasets };
        }

        /**
         * Erstellt oder aktualisiert das Chart.js-Chart.
         * @param {Object} data - Die vorbereiteten Chart-Daten.
         * @param {string} startDate - Startdatum.
         * @param {string} endDate - Enddatum.
         */
        function renderChart(data, startDate, endDate) {
            const ctx = document.getElementById('performanceChart').getContext('2d');

            if (performanceChart) {
                performanceChart.destroy(); // Vorhandenes Chart zerstÃ¶ren, falls vorhanden
            }

            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#e0e0e0'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Index Performance Vergleich (Basis 100 in CHF)',
                            font: { size: 16 },
                            color: '#e0e0e0'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2) + ' (Basis 100)';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'year',
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            ticks: {
                                source: 'auto',
                                autoSkip: true,
                                maxRotation: 0,
                                color: '#e0e0e0'
                            },
                            title: {
                                display: true,
                                text: 'Datum',
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            min: new Date(startDate).getTime(),
                            max: new Date(endDate).getTime()
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Indexwert (Basis 100)',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            beginAtZero: false,
                            suggestedMin: 80
                        }
                    }
                }
            });
        }

        /**
         * Berechnet und zeigt Statistiken (CAGR und Kursanstieg) an.
         */
        function calculateAndDisplayStatistics(data, startDate, endDate) {
            const statsContent = document.getElementById('statsContent');
            statsContent.innerHTML = '';

            data.datasets.forEach(dataset => {
                if (dataset.data.length === 0) return;

                const firstValue = dataset.data[0].y;
                const lastValue = dataset.data[dataset.data.length - 1].y;
                const totalReturn = ((lastValue - firstValue) / firstValue) * 100;

                // CAGR berechnen
                const start = new Date(startDate);
                const end = new Date(endDate);
                const years = (end - start) / (1000 * 60 * 60 * 24 * 365.25);
                const cagr = (Math.pow(lastValue / firstValue, 1 / years) - 1) * 100;

                const statRow = document.createElement('div');
                statRow.className = 'stat-row';
                statRow.innerHTML = `
                    <div class="stat-label" style="color: ${dataset.borderColor}">${dataset.label}</div>
                    <div>
                        <span style="margin-right: 20px;">Kursanstieg: <strong>${totalReturn.toFixed(2)}%</strong></span>
                        <span>CAGR: <strong>${cagr.toFixed(2)}%</strong></span>
                    </div>
                `;
                statsContent.appendChild(statRow);
            });
        }

        // Initialisiere Date Range Slider
        function initDateSlider() {
            const minDate = new Date('2000-01-01').getTime();
            const maxDate = new Date().getTime();

            dateSlider = document.getElementById('dateSlider');

            noUiSlider.create(dateSlider, {
                start: [minDate, maxDate],
                connect: true,
                range: {
                    'min': minDate,
                    'max': maxDate
                },
                step: 24 * 60 * 60 * 1000, // 1 Tag
                tooltips: [
                    {
                        to: function(value) {
                            return new Date(value).toISOString().split('T')[0];
                        }
                    },
                    {
                        to: function(value) {
                            return new Date(value).toISOString().split('T')[0];
                        }
                    }
                ]
            });

            dateSlider.noUiSlider.on('update', function(values) {
                selectedStartDate = new Date(parseInt(values[0])).toISOString().split('T')[0];
                selectedEndDate = new Date(parseInt(values[1])).toISOString().split('T')[0];
                document.getElementById('startDateLabel').textContent = selectedStartDate;
                document.getElementById('endDateLabel').textContent = selectedEndDate;
            });

            // Automatisches Nachladen bei Slider-Ã„nderung (nach dem Loslassen)
            dateSlider.noUiSlider.on('change', function(values) {
                if (performanceChart) {
                    console.log('Slider geÃ¤ndert, lade Daten neu...');
                    loadAndRenderChart();
                }
            });
        }

        // Automatisches Nachladen bei Datumswechsel
        function checkForDateChange() {
            const currentDate = new Date().toDateString();
            if (currentDate !== lastLoadDate && performanceChart) {
                console.log('Datumswechsel erkannt, lade Daten neu...');
                loadAndRenderChart();
            }
        }

        // PrÃ¼fe alle 5 Minuten auf Datumswechsel
        setInterval(checkForDateChange, 5 * 60 * 1000);

        // PrÃ¼fe auch beim Fokus der Seite
        window.addEventListener('focus', checkForDateChange);

        // Starte das Chart beim Laden der Seite
        document.addEventListener('DOMContentLoaded', () => {
             initDateSlider();
             const errorDiv = document.getElementById('error');
             errorDiv.textContent = 'Der Server (yfinance) lÃ¤uft auf http://127.0.0.1:5000. Klicken Sie auf "Chart aktualisieren", um die Daten zu laden.';
             errorDiv.style.display = 'block';
             errorDiv.style.color = 'green';
        });

    </script>

</body>
</html>