<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Performance Comparison</title>
    <script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
    <style>
        :root {
            --primary-bg: #f8f9fa;
            --secondary-bg: #ffffff;
            --text-color: #212529;
            --header-color: #343a40;
            --accent-color: #007bff;
            --border-color: #dee2e6;
            --shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            margin: 0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }
        header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        h1 {
            margin: 0;
            color: var(--header-color);
            font-size: 1.75rem;
            text-align: center;
        }
        h1 span {
            font-size: 1rem;
            color: #6c757d;
            font-weight: 400;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            padding: 1.5rem;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        .slider-group {
            min-width: 250px;
            flex: 1;
        }
        .slider-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .slider-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .date-display {
            font-weight: 600;
            color: var(--accent-color);
        }
        main {
            padding: 1.5rem;
        }
        #chart {
            width: 100%;
            height: 500px;
        }
        #metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
            margin-top: 1rem;
        }
        .metric-card {
            background-color: var(--primary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }
        .metric-card h3 {
            margin: 0 0 1rem 0;
            font-size: 1.2rem;
        }
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 0.9rem;
            color: #6c757d;
        }
        #loader, #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: var(--shadow);
            text-align: center;
            z-index: 10;
        }
        #error {
            color: #dc3545;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>Index Performance Comparison <br><span>Normalised to 100 in CHF</span></h1>
        </header>

        <div class="controls">
            <div class="slider-group">
                <label for="startYear">Start Year: <span id="startYearLabel" class="date-display">2000</span></label>
                <input type="range" id="startYear" min="2000" max="2023" value="2000">
            </div>
            <div class="slider-group">
                <label for="endYear">End Year: <span id="endYearLabel" class="date-display">2023</span></label>
                <input type="range" id="endYear" min="2000" max="2023" value="2023">
            </div>
        </div>

        <main>
            <div id="chart"></div>
        </main>

        <div id="metrics"></div>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        <p>Fetching and processing financial data...</p>
    </div>
    <div id="error" style="display: none;"></div>

    <script>
        const TICKERS = {
            dax: '^GDAXI',
            smi: '^SSMI', // SMI Price Index, will be combined with dividend data
            smiDividends: 'CHDVD.SW', // SMI Dividend Points
            sp500: '^SP500TR',
            eurChf: 'EURCHF=X',
            usdChf: 'USDCHF=X'
        };

        const CACHE = {};

        const startYearSlider = document.getElementById('startYear');
        const endYearSlider = document.getElementById('endYear');
        const startYearLabel = document.getElementById('startYearLabel');
        const endYearLabel = document.getElementById('endYearLabel');
        const chartDiv = document.getElementById('chart');
        const metricsDiv = document.getElementById('metrics');
        const loader = document.getElementById('loader');
        const errorDiv = document.getElementById('error');

        function showError(message) {
            errorDiv.textContent = `Error: ${message}. Please try again later. Some financial data APIs may be temporarily unavailable.`;
            errorDiv.style.display = 'block';
            loader.style.display = 'none';
        }

        async function fetchProxy(url) {
            // Using a public CORS proxy to get around browser restrictions
            const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
            const response = await fetch(proxyUrl, { 
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
            if (!response.ok) {
                throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
            }
            return response;
        }

        async function fetchYahooData(ticker, startDate, endDate) {
            if (CACHE[ticker]) return CACHE[ticker];
            
            const startTimestamp = Math.floor(startDate.getTime() / 1000);
            const endTimestamp = Math.floor(endDate.getTime() / 1000);
            const url = `https://query1.finance.yahoo.com/v7/finance/download/${ticker}?period1=${startTimestamp}&period2=${endTimestamp}&interval=1d&events=history`;

            try {
                const response = await fetchProxy(url);
                const csvText = await response.text();
                const lines = csvText.split('\n').slice(1);
                const data = {};
                lines.forEach(line => {
                    const [date, open, high, low, close] = line.split(',');
                    if (date && close && close !== 'null') {
                        data[date] = parseFloat(close);
                    }
                });
                CACHE[ticker] = data;
                return data;
            } catch (e) {
                console.error(e);
                showError(`Could not load data for ticker ${ticker}`);
                throw e;
            }
        }
        
        function createSMITotalReturn(smiPrice, smiDividends) {
            const smiTR = {};
            let lastDivPoints = 0;
            let rebaseFactor = 1;

            const sortedDates = Object.keys(smiPrice).sort();
            
            // Find initial dividend points before our series starts for accurate calculation
            const sortedDivDates = Object.keys(smiDividends).sort();
            const firstDataDate = sortedDates[0];
            let initialDivPoints = 0;
            for(let i = sortedDivDates.length - 1; i >= 0; i--) {
                if (sortedDivDates[i] < firstDataDate) {
                    initialDivPoints = smiDividends[sortedDivDates[i]];
                    break;
                }
            }
            lastDivPoints = initialDivPoints;

            sortedDates.forEach(date => {
                const price = smiPrice[date];
                const currentDivPoints = smiDividends[date] || lastDivPoints;

                if (currentDivPoints > lastDivPoints) {
                    const prevPrice = smiPrice[Object.keys(smiPrice).filter(d => d < date).pop()];
                    if (prevPrice) {
                        rebaseFactor *= (prevPrice + (currentDivPoints - lastDivPoints)) / prevPrice;
                    }
                    lastDivPoints = currentDivPoints;
                }
                smiTR[date] = price * rebaseFactor;
            });
            return smiTR;
        }


        async function getAllData() {
            const today = new Date();
            const maxEndDate = new Date(today.getFullYear(), 11, 31);
            const startDate = new Date(2000, 0, 1);

            const promises = Object.values(TICKERS).map(ticker => fetchYahooData(ticker, startDate, maxEndDate));
            
            try {
                await Promise.all(promises);
                
                // Combine SMI price and dividends to create SMI Total Return
                CACHE.smi_tr = createSMITotalReturn(CACHE[TICKERS.smi], CACHE[TICKERS.smiDividends]);

                loader.style.display = 'none';
                return true;
            } catch (e) {
                return false;
            }
        }

        function updateChartAndMetrics() {
            const start = parseInt(startYearSlider.value);
            const end = parseInt(endYearSlider.value);

            if (start > end) {
                endYearSlider.value = start;
                endYearLabel.textContent = start;
                updateChartAndMetrics();
                return;
            }

            startYearLabel.textContent = start;
            endYearLabel.textContent = end;

            const startDate = new Date(start, 0, 1);
            const endDate = new Date(end, 11, 31);

            const alignedData = {
                dates: [],
                dax: [],
                smi: [],
                sp500: []
            };

            let currentDate = new Date(startDate);
            let lastValues = {
                dax: null, smi: null, sp500: null,
                eurChf: null, usdChf: null
            };

            while (currentDate <= endDate) {
                const dateStr = currentDate.toISOString().split('T')[0];
                
                const eurChfRate = CACHE[TICKERS.eurChf][dateStr] || lastValues.eurChf;
                const usdChfRate = CACHE[TICKERS.usdChf][dateStr] || lastValues.usdChf;
                const daxValue = CACHE[TICKERS.dax][dateStr];
                const smiValue = CACHE.smi_tr[dateStr];
                const sp500Value = CACHE[TICKERS.sp500][dateStr];

                if (eurChfRate && usdChfRate && (daxValue || smiValue || sp500Value)) {
                    alignedData.dates.push(dateStr);
                    
                    const daxChf = (daxValue || lastValues.dax) * eurChfRate;
                    const smiChf = smiValue || lastValues.smi;
                    const sp500Chf = (sp500Value || lastValues.sp500) * usdChfRate;

                    alignedData.dax.push(daxChf);
                    alignedData.smi.push(smiChf);
                    alignedData.sp500.push(sp500Chf);

                    lastValues = {
                        dax: daxChf, smi: smiChf, sp500: sp500Chf,
                        eurChf: eurChfRate, usdChf: usdChfRate
                    };
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Normalize data
            const firstDax = alignedData.dax.find(v => v !== null);
            const firstSmi = alignedData.smi.find(v => v !== null);
            const firstSp500 = alignedData.sp500.find(v => v !== null);

            const normalizedDax = alignedData.dax.map(v => v / firstDax * 100);
            const normalizedSmi = alignedData.smi.map(v => v / firstSmi * 100);
            const normalizedSp500 = alignedData.sp500.map(v => v / firstSp500 * 100);

            // Render Chart
            const traces = [
                { x: alignedData.dates, y: normalizedDax, name: 'DAX', line: { color: '#007bff' } },
                { x: alignedData.dates, y: normalizedSmi, name: 'SMI (TR)', line: { color: '#dc3545' } },
                { x: alignedData.dates, y: normalizedSp500, name: 'S&P 500 (TR)', line: { color: '#28a745' } }
            ];

            Plotly.react(chartDiv, traces, {
                title: `Index Performance (${start} - ${end})`,
                yaxis: { title: 'Normalized Value (CHF)' },
                xaxis: { title: 'Date' }
            });

            // Calculate and Render Metrics
            metricsDiv.innerHTML = '';
            const indices = [
                { name: 'DAX', data: normalizedDax },
                { name: 'SMI (TR)', data: normalizedSmi },
                { name: 'S&P 500 (TR)', data: normalizedSp500 }
            ];

            const years = (endDate - startDate) / (1000 * 60 * 60 * 24 * 365.25);

            indices.forEach(index => {
                const lastValue = index.data[index.data.length - 1];
                const growth = lastValue - 100;
                const cagr = (Math.pow(lastValue / 100, 1 / years) - 1) * 100;

                const card = `
                    <div class="metric-card">
                        <h3>${index.name}</h3>
                        <p class="metric-value">${growth.toFixed(2)}%</p>
                        <p class="metric-label">Total Growth</p>
                        <p class="metric-value">${cagr.toFixed(2)}%</p>
                        <p class="metric-label">CAGR</p>
                    </div>
                `;
                metricsDiv.innerHTML += card;
            });
        }

        async function init() {
            const today = new Date();
            const currentYear = today.getFullYear();
            startYearSlider.max = currentYear -1;
            endYearSlider.max = currentYear;
            endYearSlider.value = currentYear;
            startYearLabel.textContent = startYearSlider.value;
            endYearLabel.textContent = endYearSlider.value;

            const success = await getAllData();
            if (success) {
                updateChartAndMetrics();
                startYearSlider.addEventListener('input', () => {
                    startYearLabel.textContent = startYearSlider.value;
                    if (parseInt(startYearSlider.value) > parseInt(endYearSlider.value)) {
                        endYearSlider.value = startYearSlider.value;
                        endYearLabel.textContent = startYearSlider.value;
                    }
                });
                endYearSlider.addEventListener('input', () => {
                    endYearLabel.textContent = endYearSlider.value;
                     if (parseInt(startYearSlider.value) > parseInt(endYearSlider.value)) {
                        startYearSlider.value = endYearSlider.value;
                        startYearLabel.textContent = endYearSlider.value;
                    }
                });
                startYearSlider.addEventListener('change', updateChartAndMetrics);
                endYearSlider.addEventListener('change', updateChartAndMetrics);
            }
        }

        window.onload = init;
    </script>
</body>
</html>
